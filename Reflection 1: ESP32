#include <WiFi.h>
#include <PubSubClient.h>

// WiFi settings
const char* ssid = "SSID";
const char* password = "PASSWORD";

// MQTT settings
const char* mqtt_server = "IP";

// MQTT topics
const char* led_control_topic = "thanos/led/control";
const char* clap_topic = "thanos/clap";

WiFiClient espClient;
PubSubClient client(espClient);
unsigned long lastHeartbeat = 0;

// Hardware pins
const int MIC_PIN = 34;
const int LED_PIN = 33;

// Audio processing
const int SMOOTH_SAMPLES = 15;
int noiseFloor = 0;
int CLAP_THRESHOLD = 600;

// Timing constants
const unsigned long MIN_GAP = 70;
const unsigned long COOLDOWN = 100;
const unsigned long SEQ_TIMEOUT = 1000;
const unsigned long PRINT_INTERVAL = 60;

// Clap detection state
unsigned long lastPeakTime = 0;
bool inCooldown = false;

// PWM configuration
const int PWM_CH = 0;

// LED state
int ledBrightness = 128;
const int step = 50;

// Clap counting
int clapCount = 0;
unsigned long lastClapTime = 0;

// Sensor monitoring
unsigned long lastPrint = 0;

// Function declarations
void setupWiFi();
void callback(char* topic, byte* payload, unsigned int length);
void reconnect();
void publishClapPattern(int pattern);
int smoothRead(int pin);
int calibrateNoise(int pin, int samples = 200, int delayMs = 3);
bool isPeak(int value);
void setupLED();
void setLEDBrightness(int b);
void handleWebClapPattern(int pattern);
void handleLocalClapPattern(int pattern);
void parseAndHandleWebClap(String message);

void setupWiFi() {
  delay(10);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("MQTT Message: ");
  Serial.print(topic);
  Serial.print(" - ");
  
  String message;
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  Serial.println(message);

  if (String(topic) == led_control_topic) {
    if (message == "ON") {
      setLEDBrightness(128);
      Serial.println("COMMAND: LED ON");
    } else if (message == "OFF") {
      setLEDBrightness(0);
      Serial.println("COMMAND: LED OFF");
    } else if (message.startsWith("BRIGHTNESS:")) {
      int brightness = message.substring(11).toInt();
      setLEDBrightness(brightness);
      Serial.print("COMMAND: Brightness ");
      Serial.println(brightness);
    }
  } else if (String(topic) == clap_topic) {
    Serial.println("ðŸ“¨ Received clap pattern from web");
    parseAndHandleWebClap(message);
  }
}

void parseAndHandleWebClap(String message) {
  int pattern = 0;
  int startPos = message.indexOf("\"pattern\":");
  if (startPos != -1) {
    startPos += 10;
    int endPos = message.indexOf(",", startPos);
    if (endPos == -1) endPos = message.indexOf("}", startPos);
    if (endPos != -1) {
      String patternStr = message.substring(startPos, endPos);
      pattern = patternStr.toInt();
    }
  }

  Serial.print("ðŸŽ¯ Web clap pattern: ");
  Serial.println(pattern);
  handleWebClapPattern(pattern);
}

void handleWebClapPattern(int pattern) {
  switch (pattern) {
    case 1:
      if (ledBrightness > 0) {
        Serial.println("Web 1 Clap = LED OFF");
        setLEDBrightness(0);
      } else {
        Serial.println("Web 1 Clap = LED ON");
        setLEDBrightness(128);
      }
      break;
      
    case 2:
      Serial.println("Web 2 Claps = -50 brightness");
      setLEDBrightness(ledBrightness - step);
      break;

    case 3:
      Serial.println("Web 3 Claps = +50 brightness");
      setLEDBrightness(ledBrightness + step);
      break;

    case 4:
      Serial.println("Web 4 Claps = MAX brightness");
      setLEDBrightness(255);
      break;
  }
}

void handleLocalClapPattern(int pattern) {
  switch (pattern) {
    case 1:
      if (ledBrightness > 0) {
        Serial.println("1 Clap = LED OFF");
        setLEDBrightness(0);
      } else { 
        Serial.println("1 Clap = LED ON");
        setLEDBrightness(128);
      }
      break;

    case 2:
      Serial.println("2 Claps = -50 brightness");
      setLEDBrightness(ledBrightness - step);
      break;

    case 3:
      Serial.println("3 Claps = +50 brightness");
      setLEDBrightness(ledBrightness + step);
      break;

    case 4:
      Serial.println("4 Claps = MAX brightness");
      setLEDBrightness(255);
      break;
  }
}

void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    String clientId = "ESP32Client-";
    clientId += String(random(0xffff), HEX);
    
    if (client.connect(clientId.c_str())) {
      Serial.println("CONNECTED to MQTT!");
      client.subscribe(led_control_topic);
      client.subscribe(clap_topic);  // FIX: Subscribe to clap topic
      Serial.println("Subscribed to LED control and clap topics");
      client.publish("thanos/system/esp32", "online");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" - retrying in 5 seconds");
      delay(5000);
    }
  }
}

void publishClapPattern(int pattern) {
  String message = "{\"pattern\":" + String(pattern) + "}";
  client.publish(clap_topic, message.c_str());
  Serial.print("Published pattern: ");
  Serial.println(pattern);
}

int smoothRead(int pin) {
  long s = 0;
  for (int i = 0; i < SMOOTH_SAMPLES; ++i) {
    s += analogRead(pin);
  }
  return s / SMOOTH_SAMPLES;
}

int calibrateNoise(int pin, int samples, int delayMs) {
  long s = 0;
  for (int i = 0; i < samples; ++i) {
    s += smoothRead(pin);
    delay(delayMs);
  }
  return (int)(s / samples);
}

bool isPeak(int value) {
  return value >= CLAP_THRESHOLD;
}

void setupLED() {
  ledcSetup(PWM_CH, 5000, 8);
  ledcAttachPin(LED_PIN, PWM_CH);
  ledcWrite(PWM_CH, 0);
}

void setLEDBrightness(int b) {
  b = constrain(b, 0, 255);
  ledBrightness = b; 
  ledcWrite(PWM_CH, ledBrightness);
  
  if (b == 0) {
    client.publish("thanos/led/status", "OFF");
    Serial.println("Published: LED OFF");
  } else {
    String message = "BRIGHTNESS:" + String(b);
    client.publish("thanos/led/status", message.c_str());
    Serial.println("Published: Brightness " + String(b));
  }
}

void setup() {
  Serial.begin(115200);
  delay(300);
  
  setupWiFi();
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
  pinMode(MIC_PIN, INPUT);
  noiseFloor = calibrateNoise(MIC_PIN);
  setupLED();

  client.publish("thanos/system/esp32", "online");

  Serial.println("Clap detection system started!");
  Serial.print("Noise floor: ");
  Serial.println(noiseFloor);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
  
  unsigned long now = millis();

  if (now - lastPrint >= PRINT_INTERVAL) {
    int val = smoothRead(MIC_PIN);
    Serial.print("Mic: "); 
    Serial.println(val);
    lastPrint = now;
  }

  if (millis() - lastHeartbeat > 5000) {
    client.publish("thanos/heartbeat", "alive");
    lastHeartbeat = millis();
  }

  int micVal = smoothRead(MIC_PIN);

  if (inCooldown) {
    if (micVal < CLAP_THRESHOLD * 0.6) {
      inCooldown = false;
    }
  }

  if (!inCooldown && isPeak(micVal) && (now - lastPeakTime) > MIN_GAP) {
    clapCount++;
    lastClapTime = now;
    lastPeakTime = now;
    inCooldown = true;

    Serial.print("Clap detected. Count = ");
    Serial.println(clapCount);
    publishClapPattern(clapCount);
  }

  if (clapCount > 0 && (now - lastClapTime) > SEQ_TIMEOUT) {
    Serial.print("Final pattern detected: ");
    Serial.println(clapCount);
    handleLocalClapPattern(clapCount);
    clapCount = 0;
  }
  
  delay(10);
}
