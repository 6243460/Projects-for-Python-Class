#include <WiFi.h>
#include <PubSubClient.h>

// WiFi settings
const char* ssid = "iot_wireless";
const char* password = "passphrase";

// MQTT settings (Raspberry Pi IP)
const char* mqtt_server = "192.168.68.78";

// MQTT topics
const char* clap_detect_topic = "thanos/clap/detected";
const char* led_command_topic = "thanos/led/command";
const char* heartbeat_topic = "thanos/esp32/heartbeat";
const char* led_feedback_topic = "thanos/led/feedback";

WiFiClient espClient;
PubSubClient client(espClient);
unsigned long lastHeartbeat = 0;
unsigned long lastPrint = 0;

// Hardware pins
const int MIC_PIN = 34;
const int LED_PIN = 33;

// Audio processing
const int SMOOTH_SAMPLES = 15;
int noiseFloor = 0;  //background noise
int CLAP_THRESHOLD = 400;  //value needed on serial monitor to detect a calp

// Timing constants
const unsigned long MIN_GAP = 70; //ms, gap between claps
const unsigned long COOLDOWN = 100;
const unsigned long SEQ_TIMEOUT = 1000;
const unsigned long PRINT_INTERVAL = 1000;  // Print every 1 second

// Clap detection state
unsigned long lastPeakTime = 0;
bool inCooldown = false;

// PWM configuration
const int PWM_CH = 0;

// LED state (only follows commands from Pi)
int ledBrightness = 0;

// Clap counting
int clapCount = 0;
unsigned long lastClapTime = 0;

// Function declarations
void setupWiFi();
void callback(char* topic, byte* payload, unsigned int length);
void reconnect();
void sendClapDetection(int pattern, int micValue);
int smoothRead(int pin);
int calibrateNoise(int pin, int samples = 200, int delayMs = 3);
bool isPeak(int value);
void setupLED();
void setLEDFromCommand(String command);
void handleLEDCommand(String message);

void setupWiFi() {
  delay(10);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("MQTT Message: ");
  Serial.print(topic);
  Serial.print(" - ");
  
  String message;
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  Serial.println(message);

  if (String(topic) == led_command_topic) {
    handleLEDCommand(message);
  }
}

void handleLEDCommand(String message) {
  Serial.print("Received LED command from Pi: ");
  Serial.println(message);
  
  if (message == "ON") {
    setLEDFromCommand("ON");
    client.publish(led_feedback_topic, "ON");
    Serial.println("Following Pi command: LED ON");
  } else if (message == "OFF") {
    setLEDFromCommand("OFF");
    client.publish(led_feedback_topic, "OFF");
    Serial.println("Following Pi command: LED OFF");
  } else if (message.startsWith("BRIGHTNESS:")) {
    setLEDFromCommand(message);
    String feedback = "BRIGHTNESS:" + String(ledBrightness);
    client.publish(led_feedback_topic, feedback.c_str());
    Serial.print("Following Pi command: Brightness ");
    Serial.println(message.substring(11));
  }
}

void setLEDFromCommand(String command) {
  if (command == "ON") {
    ledBrightness = 255;
    ledcWrite(PWM_CH, ledBrightness);
  } else if (command == "OFF") {
    ledBrightness = 0;
    ledcWrite(PWM_CH, ledBrightness);
  } else if (command.startsWith("BRIGHTNESS:")) {
    int brightness = command.substring(11).toInt();
    ledBrightness = constrain(brightness, 0, 255);
    ledcWrite(PWM_CH, ledBrightness);
  }
}

void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    String clientId = "ESP32_ClapDetector-";
    clientId += String(random(0xffff), HEX);
    
    if (client.connect(clientId.c_str())) {
      Serial.println("CONNECTED to MQTT!");
      client.subscribe(led_command_topic);
      Serial.println("Subscribed to LED commands from Pi");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" - retrying in 5 seconds");
      delay(5000);
    }
  }
}

void sendClapDetection(int pattern, int micValue) {
  String message = "{\"pattern\":" + String(pattern) + 
                   ", \"mic_value\":" + String(micValue) + "}";
  client.publish(clap_detect_topic, message.c_str());
  Serial.print(" Sent clap pattern to Pi: ");
  Serial.println(pattern);
}

int smoothRead(int pin) {
  long s = 0;
  for (int i = 0; i < SMOOTH_SAMPLES; ++i) {
    s += analogRead(pin);
  }
  return s / SMOOTH_SAMPLES;
}

int calibrateNoise(int pin, int samples, int delayMs) {
  long s = 0;
  for (int i = 0; i < samples; ++i) {
    s += smoothRead(pin);
    delay(delayMs);
  }
  return (int)(s / samples);
}

bool isPeak(int value) {
  return value >= CLAP_THRESHOLD;
}

void setupLED() {
  ledcSetup(PWM_CH, 5000, 8);
  ledcAttachPin(LED_PIN, PWM_CH);
  ledcWrite(PWM_CH, 0);
}

void setup() {
  Serial.begin(115200);
  delay(300);
  
  setupWiFi();
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
  pinMode(MIC_PIN, INPUT);
  noiseFloor = calibrateNoise(MIC_PIN);
  setupLED();

  client.publish(led_feedback_topic, "OFF");

  Serial.println("Clap detection system started!");
  Serial.print("Noise floor: ");
  Serial.println(noiseFloor);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
  
  unsigned long now = millis();

  // Print sensor values every second
  if (now - lastPrint >= PRINT_INTERVAL) {
    int val = smoothRead(MIC_PIN);
    Serial.print("Mic: "); 
    Serial.print(val);
    
    // Add LED status info
    Serial.print(" | LED: ");
    Serial.print(ledBrightness > 0 ? "ON" : "OFF");
    Serial.print(" (");
    Serial.print(int((ledBrightness / 255.0) * 100));
    Serial.println("%)");
    
    lastPrint = now;
  }

  if (millis() - lastHeartbeat > 5000) {
    client.publish(heartbeat_topic, "alive");
    lastHeartbeat = millis();
  }

  int micVal = smoothRead(MIC_PIN);

  if (inCooldown) {
    if (micVal < CLAP_THRESHOLD * 0.6) {
      inCooldown = false;
    }
  }

  if (!inCooldown && isPeak(micVal) && (now - lastPeakTime) > MIN_GAP) {
    clapCount++;
    lastClapTime = now;
    lastPeakTime = now;
    inCooldown = true;

    Serial.print("Clap detected. Count = ");
    Serial.println(clapCount);
  }

  if (clapCount > 0 && (now - lastClapTime) > SEQ_TIMEOUT) {
    Serial.print("Final pattern detected: ");
    Serial.println(clapCount);
    sendClapDetection(clapCount, micVal);
    clapCount = 0;
  }
  
  delay(10);
}
