/*I started coding the ESP32 for our project
NOTES: There are still some changes to be made.
1 CLAP FIRST TIME= LED ON at 128
1 CLAP SECOND TIME = LED OFF
2 CLAPS = -50 BRIGHTNESS 
3 CLAPS = +50 BRIGHTNESS

CODE:*/
#include <WiFi.h>
#include <PubSubClient.h>

// WiFi settings 
const char* ssid = "SSID";
const char* password = "PASSWORD";

// MQTT settings 
const char* mqtt_server = "IP";  

// MQTT topics - ADD THESE DEFINITIONS
const char* led_control_topic = "led/control";
const char* clap_topic = "clap/pattern";

WiFiClient espClient;
PubSubClient client(espClient);
unsigned long lastHeartbeat = 0; 

const int MIC_PIN = 34;
const int LED_PIN = 33;     
const int SMOOTH_SAMPLES = 15;
int noiseFloor = 0;
int CLAP_THRESHOLD = 150;

//Timing 
const unsigned long MIN_GAP = 70;   
const unsigned long COOLDOWN = 100;  
const unsigned long SEQ_TIMEOUT = 1000; 

//Clap detection
unsigned long lastPeakTime = 0;
bool inCooldown = false;

//sensor values
unsigned long lastPrint = 0;
const unsigned long PRINT_INTERVAL = 60;

//PWM
const int PWM_CH = 0;

//Brightness control
int ledBrightness = 128;       // default brightness
const int step = 50;           // increment/decrement per pattern
bool ledState = false;

//Clap counting
int clapCount = 0;
unsigned long seqStart = 0;
unsigned long lastClapTime = 0;

//Function Declaration
void setupWiFi();
void callback(char* topic, byte* payload, unsigned int length);
void reconnect();
void publishClapPattern(int pattern);
int smoothRead(int pin);
int calibrateNoise(int pin, int samples = 200, int delayMs = 3);
bool isPeak(int value);
void setupLED();
void setLEDBrightness(int b);

//MQTT Functions
void setupWiFi() {
  delay(10);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("MQTT Message: ");
  Serial.print(topic);
  Serial.print(" - ");
  
  String message;
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  Serial.println(message);

  // Handle LED control from Python
  if (String(topic) == led_control_topic) {
    if (message == "ON") {
      setLEDBrightness(128);
      Serial.println("COMMAND: LED ON");
    } else if (message == "OFF") {
      setLEDBrightness(0);
      Serial.println("COMMAND: LED OFF");
    } else if (message.startsWith("BRIGHTNESS:")) {
      int brightness = message.substring(11).toInt();
      setLEDBrightness(brightness);
      Serial.print("COMMAND: Brightness ");
      Serial.println(brightness);
    }
  }
Â  else if (String(topic) == clap_topic) {
Â  Â  Serial.println("ðŸ“¨ Received clap pattern from web");

Â  Â  // Parse the JSON message
Â  Â  int pattern = 0;
Â  Â  int startPos = message.indexOf("\"pattern\":");
Â  Â  if (startPos != -1) {
Â  Â  Â  startPos += 10; // Move past "\"pattern\":"
Â  Â  Â  int endPos = message.indexOf(",", startPos);
Â  Â  Â  if (endPos == -1) endPos = message.indexOf("}", startPos);
Â  Â  Â  if (endPos != -1) {
Â  Â  Â  Â  String patternStr = message.substring(startPos, endPos);
Â  Â  Â  Â  pattern = patternStr.toInt();
Â  Â  Â  }
Â  Â  }

Â  Â  Serial.print("ðŸŽ¯ Web clap pattern: ");
Â  Â  Serial.println(pattern);

Â  Â  // Execute the LED action based on pattern
Â  Â  switch (pattern) {
Â  Â  Â  case 1:
Â  Â  Â  Â  // Toggle LED
Â  Â  Â  Â  if (ledBrightness > 0) {
Â  Â  Â  Â  Â  Serial.println("Web 1 Clap = LED OFF");
Â  Â  Â  Â  Â  setLEDBrightness(0);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Serial.println("Web 1 Clap = LED ON");
Â  Â  Â  Â  Â  setLEDBrightness(128);
Â  Â  Â  Â  }
Â  Â  Â  Â  break;

Â  Â  Â  case 2:
Â  Â  Â  Â  // Decrease brightness
Â  Â  Â  Â  Serial.println("Web 2 Claps = -50 brightness");
Â  Â  Â  Â  setLEDBrightness(ledBrightness - step);
Â  Â  Â  Â  break;

Â  Â  Â  case 3:
Â  Â  Â  Â  // Increase brightness
Â  Â  Â  Â  Serial.println("Web 3 Claps = +50 brightness");
Â  Â  Â  Â  setLEDBrightness(ledBrightness + step);
Â  Â  Â  Â  break;

Â  Â  Â  case 4:
Â  Â  Â  Â  // Max brightness
Â  Â  Â  Â  Serial.println("Web 4 Claps = MAX brightness");
Â  Â  Â  Â  setLEDBrightness(255);
Â  Â  Â  Â  break;
Â  Â  }
Â  }
}

void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    String clientId = "ESP32Client-";
    clientId += String(random(0xffff), HEX);
    
    if (client.connect(clientId.c_str())) {
      Serial.println("CONNECTED to MQTT!");
      client.subscribe(led_control_topic);
      Serial.println("Subscribed to LED control");

      // Publish online status
      client.publish("thanos/system/esp32", "online");

    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" - retrying in 5 seconds");
      delay(5000);
    }
  }
}

void publishClapPattern(int pattern) {
  String message = "{\"pattern\":" + String(pattern) + "}";
  client.publish(clap_topic, message.c_str());
  Serial.print("Published pattern: ");
  Serial.println(pattern);
}

int smoothRead(int pin) {
  long s = 0;
  for (int i = 0; i < SMOOTH_SAMPLES; ++i) {
    s += analogRead(pin);
  }
  return s / SMOOTH_SAMPLES;
}

int calibrateNoise(int pin, int samples, int delayMs) {
  long s = 0;
  for (int i = 0; i < samples; ++i) {
    s += smoothRead(pin);
    delay(delayMs);
  }
  return (int)(s / samples);
}

bool isPeak(int value) {
  return value >= CLAP_THRESHOLD;
}

void setupLED() {
  ledcSetup(PWM_CH, 5000, 8);
  ledcAttachPin(LED_PIN, PWM_CH);
  ledcWrite(PWM_CH, 0);
}

void setLEDBrightness(int b) {
  b = constrain(b, 0, 255);
  ledBrightness = b; 
  ledcWrite(PWM_CH, ledBrightness);

  // PUBLISH LED STATUS TO MQTT
  if (b == 0) {
    client.publish("thanos/led/status", "OFF");
    Serial.println("Published: LED OFF");
  } else {
    String message = "BRIGHTNESS:" + String(b);
    client.publish("thanos/led/status", message.c_str());
    Serial.println("Published: Brightness " + String(b));
  }
}

void setup() {
  Serial.begin(115200);
  delay(300);
  
  // Initialize WiFi and MQTT
  setupWiFi();
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
  pinMode(MIC_PIN, INPUT);
  noiseFloor = calibrateNoise(MIC_PIN);
  setupLED();

  // Publish online status
  client.publish("thanos/system/esp32", "online");

  Serial.println("Clap detection system started!");
  Serial.print("Noise floor: ");
  Serial.println(noiseFloor);
}

void loop() {
  // MQTT connection maintenance
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
  unsigned long now = millis();

  //mic values 
  if (now - lastPrint >= PRINT_INTERVAL) {
    int val = smoothRead(MIC_PIN);
    Serial.print("Mic: "); 
    Serial.println(val);
    lastPrint = now;
  }

Â  if (millis() - lastHeartbeat > 5000) {
      client.publish("thanos/heartbeat", "alive");
      lastHeartbeat = millis();
Â  Â  }

  int micVal = smoothRead(MIC_PIN);

  if (inCooldown) {
    if (micVal < CLAP_THRESHOLD * 0.6) {
      inCooldown = false;
    }
  }

  if (!inCooldown && isPeak(micVal) && (now - lastPeakTime) > MIN_GAP) {
    if (clapCount == 0) {
      seqStart = now;
    }

    clapCount++;
    lastClapTime = now;
    lastPeakTime = now;
    inCooldown = true;

    Serial.print("Clap detected. Count = ");
    Serial.println(clapCount);

    // Publish clap pattern for visualization
    publishClapPattern(clapCount);
  }

  // If timeout passed â†’ evaluate pattern
  if (clapCount > 0 && (now - lastClapTime) > SEQ_TIMEOUT) {
    Serial.print("Final pattern detected: ");
    Serial.println(clapCount);

    // LED ACTIONS
switch (clapCount) {
  case 1:  // toggle on/off
    if (ledBrightness > 0) {
      Serial.println("1 Clap = LED OFF");
      setLEDBrightness(0);
      ledState = false;
    } else { 
      Serial.println("1 Clap = LED ON");
      setLEDBrightness(128);
    }
    break;

  case 2: // brightness -50
    Serial.println("2 Claps = - brightness");
    setLEDBrightness(ledBrightness - step);
    break;

  case 3:  // brightness +50
    Serial.println("3 Claps = + brightness");
    setLEDBrightness(ledBrightness + step);
    break;

  case 4:  // max brightness
    Serial.println("4 Claps = MAX brightness");
    setLEDBrightness(255);
    break;
}

    // RESET 
    clapCount = 0;
  }
  
  delay(10);
}
